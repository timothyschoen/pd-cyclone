#N canvas 415 39 564 673 10;
#X obj 8 644 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X obj 7 453 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 7 567 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 7 599 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X obj 82 576 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X text 133 576 signal;
#X text 133 461 signal;
#X text 121 623 2) float;
#X obj 82 462 cnv 17 3 97 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X text 139 499 float;
#X msg 46 195 mode \$1;
#X obj 46 168 tgl 20 0 empty empty empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X text 121 605 1) float;
#X text 189 576 - output of bit shifted signal;
#X text 189 606 - number of bits to shift (default 0);
#X msg 146 206 shift \$1;
#X text 109 479 mode <0/1>;
#X text 189 478 - sets mode (details above);
#X obj 279 220 cnv 15 265 80 empty empty empty 20 12 0 14 #f4f4f4 #404040 0;
#X text 286 223 Modes:;
#X text 292 240 0: (default) doesn't convert to int;
#N canvas 617 310 476 167 signal_conversion_to_int 0;
#X text 62 35 Signals are 32 bit floating point by default and their 32 bit representation is used for comparison. When converting a signal to integer \, depending on the mode \, what happens is that the floating point value is converted/truncated to an integer \, and the 32 bit signed integer representation of this value is used for the operation.;
#X restore 369 276 pd signal_conversion_to_int;
#X text 292 253 1: converts input signal to int;
#X text 91 518 shift <float>;
#X obj 107 241 cyclone/bitshift~ -2;
#X text 189 518 - specifies the number and direction of the shift - positive values shift that number of bits to the left while negative shift to the right;
#X text 189 499 - sets conversion mode [0 or 1];
#X text 191 624 - sets conversion mode: 0 (default) or 1;
#X text 189 462 - signal to Bit-Shift;
#X obj 146 182 nbx 5 16 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 12 #dcdcdc #000000 #000000 0 256;
#X obj 500 69 cyclone/dsponoff~;
#X obj 2 2 header bitshift~;
#X text 23 60 Signal Bit-Shifting;
#X floatatom 107 158 11 0 0 0 - - - 0;
#X obj 107 181 sig~;
#X obj 107 270 cyclone/snapshot~ 1;
#X floatatom 107 297 11 0 0 0 - - - 0;
#X text 37 348 see also;
#X text 17 365 as a vanilla alternative, f 12;
#X obj 453 382 open-else;
#X msg 453 355 op~;
#X text 45 89 [bitshift~] takes a signal and performs Bitwise Shifting (shift bit values to the left or right) depending on a shift value (positive values shift that number of bits to the left \, while negative values shift to the right)., f 68;
#X text 238 159 [bitshift~] can produce NaNs and +/-INFs - but denormals are zeroed out. The operation is done in two modes (see below)., f 47;
#X obj 99 350 expr~ $v1 >> $v2;
#X obj 99 371 expr~ $v1 << $v2;
#X text 234 354 Plugdata users or those with ELSE can also use [else/op~ >>] or [else/op~ <<] (both would be the same as" mode 1"), f 31;
#N canvas 294 162 325 299 bitwise-cyclone 0;
#X obj 88 53 cyclone/bitand~;
#X obj 88 82 cyclone/bitnot~;
#X obj 88 111 cyclone/bitor~;
#X obj 88 140 cyclone/bitshift~;
#X obj 88 169 cyclone/bitxor~;
#X obj 91 240 cyclone/bitshift~;
#X text 78 20 All bitwise operators in Cyclone;
#X text 86 211 See also:;
#X restore 91 399 pd bitwise-cyclone;
#X text 58 400 and;
#X text 480 353 <- click;
#X connect 10 0 24 0;
#X connect 11 0 10 0;
#X connect 15 0 24 0;
#X connect 24 0 35 0;
#X connect 29 0 15 0;
#X connect 33 0 34 0;
#X connect 34 0 24 0;
#X connect 35 0 36 0;
#X connect 40 0 39 0;
