#N canvas 440 62 560 665 10;
#X declare -stdpath ./;
#X obj 5 636 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X obj 5 413 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 5 522 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 82 531 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X text 134 531 signal;
#X obj 84 421 cnv 17 3 54 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 83 480 cnv 17 3 31 empty empty 1 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 8 555 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X text 133 421 signal;
#X text 122 563 1) float;
#X msg 32 191 mode \$1;
#X obj 32 172 nbx 2 12 0 3 0 0 safsdf sdfsdf empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X text 134 479 signal;
#X text 140 496 float;
#X text 103 440 bits <list>;
#X text 122 581 2) float;
#X text 101 158 Compare two signals:;
#X text 184 458 - <0-3>: modes of conversion to integers (details above);
#X text 184 563 - converted to integer and used as bitmask (default 0);
#X obj 304 159 cnv 15 240 110 empty empty empty 20 12 0 14 #f4f4f4 #404040 0;
#X text 313 163 Modes:;
#X text 317 180 0: (default) doesn't convert to int;
#X text 317 206 2: converts right signal to int;
#X text 317 219 3: converts left signal to int;
#N canvas 655 448 476 167 signal_conversion_to_int 0;
#X text 59 31 Signals are 32 bit floating point by default and their 32 bit representation is used for comparison. When converting a signal to integer \, depending on the mode \, what happens is that the floating point value is converted/truncated to an integer value (1.7 becomes 1 \, for instance) and the 32 bit signed integer representation of this value is used for comparison.;
#X restore 363 243 pd signal_conversion_to_int;
#X text 97 457 mode <float>;
#X text 317 193 1: converts both signals to int;
#X text 183 439 - bits plus 32 bit (0/1) values sets a raw 32-bits bitmask;
#X text 239 279 compare to a;
#X text 234 291 given bitmask:;
#X obj 32 107 vradio 15 1 0 4 dfhdfgdj sggh empty 0 -8 0 10 #dcdcdc #000000 #000000 0;
#X text 22 106 0;
#X text 22 120 1;
#X text 22 136 2;
#X text 22 151 3;
#X text 184 497 - converted to integer and used as bitmask;
#X text 184 581 - mode [0-3] (details above) - default 0;
#X obj 92 231 cyclone/bitxor~;
#X text 183 421 - signal to execute Bitwise-XOR on;
#X text 184 531 - signal as result of the "Bitwise-XOR" operation;
#X text 184 479 - signal to execute Bitwise-XOR on;
#X obj 2 605 cnv 3 550 3 empty empty attributes 8 12 0 13 #dcdcdc #000000 0;
#X text 140 612 @mode <float>: sets conversion mode (default 0);
#N canvas 772 117 478 556 integer_bitmask 0;
#X obj 262 315 nbx 5 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X msg 61 311 mode \$1;
#X obj 61 292 nbx 2 12 0 3 0 0 safsdf sdfsdf empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X obj 61 227 vradio 15 1 0 4 dfhdfgdj sggh empty 0 -8 0 10 #dcdcdc #000000 #000000 0;
#X text 51 226 0;
#X text 51 240 1;
#X text 51 256 2;
#X text 51 271 3;
#X obj 127 193 cnv 15 240 85 empty empty empty 20 12 0 14 #f4f4f4 #404040 0;
#X text 136 197 Modes:;
#X text 140 214 0: left as float (don't convert);
#X text 140 227 1: convert left input to integer;
#X text 140 240 2: left as float (don't convert);
#X text 140 253 3: convert left input to integer;
#X text 41 38 When a first argument is given \, this value is converted to an integer and the e '32 bit signed integer' representation of this value is used as a bitmask for comparison.;
#X text 43 101 Since there is no audio input in the second inlet \, the modes of conversion don't really make the same sense here. The bitmask for comparison is always the same and only the left input is converted to int or not. Thus \, here's how the modes will operate:;
#X text 55 455 A float input into the second inlet is converted to int and updates the argument. If a signal is connected to the second inlet \, the float input will still update the argument \, but the signal input has priority over the argument or the float input.;
#X text 278 355 <= integer bitmask;
#X text 286 370 (1st argument);
#X text 266 295 updates bitmask;
#X text 323 314 (converted to int);
#X obj 139 355 cyclone/bitxor~ 10 1, f 21;
#X floatatom 139 306 13 0 0 0 - - - 0;
#X obj 139 329 sig~;
#X obj 139 382 cyclone/snapshot~ 1;
#X floatatom 139 407 13 0 0 0 - - - 0;
#X connect 0 0 21 1;
#X connect 1 0 21 0;
#X connect 2 0 1 0;
#X connect 3 0 2 0;
#X connect 21 0 24 0;
#X connect 22 0 23 0;
#X connect 23 0 21 0;
#X connect 24 0 25 0;
#X restore 330 284 pd integer_bitmask;
#N canvas 586 34 691 648 raw_bitmask 0;
#N canvas 303 196 881 396 x 0;
#X obj 201 101 cnv 15 458 44 empty empty empty 20 12 0 14 #f0f0f0 #404040 0;
#X obj 407 103 tgl 15 0 \$0-alkdjg \$0-sfdknj empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 640 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 625 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 611 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 597 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 583 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 569 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 555 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 541 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 527 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 512 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 498 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 484 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 470 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 456 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 442 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 428 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 414 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 400 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 386 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 372 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 358 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 344 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 330 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 316 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 302 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 288 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 274 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 260 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 246 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 232 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 218 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 204 124 tgl 15 0 \$0-bitchange asjgsjags empty 17 7 0 10 #dcdcdc #000000 #000000 0 1;
#X obj 71 306 outlet;
#X obj 407 50 loadbang;
#X obj 71 179 cyclone/pak bits i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i, f 126;
#X obj 71 251 t b a;
#X obj 71 220 cyclone/prepend set;
#X text 424 103 set all bits;
#X msg 407 74 0;
#X connect 1 0 33 0;
#X connect 1 0 32 0;
#X connect 1 0 31 0;
#X connect 1 0 30 0;
#X connect 1 0 29 0;
#X connect 1 0 28 0;
#X connect 1 0 27 0;
#X connect 1 0 26 0;
#X connect 1 0 25 0;
#X connect 1 0 24 0;
#X connect 1 0 23 0;
#X connect 1 0 22 0;
#X connect 1 0 21 0;
#X connect 1 0 20 0;
#X connect 1 0 19 0;
#X connect 1 0 18 0;
#X connect 1 0 17 0;
#X connect 1 0 16 0;
#X connect 1 0 15 0;
#X connect 1 0 14 0;
#X connect 1 0 13 0;
#X connect 1 0 12 0;
#X connect 1 0 11 0;
#X connect 1 0 10 0;
#X connect 1 0 9 0;
#X connect 1 0 8 0;
#X connect 1 0 7 0;
#X connect 1 0 6 0;
#X connect 1 0 5 0;
#X connect 1 0 4 0;
#X connect 1 0 3 0;
#X connect 1 0 2 0;
#X connect 2 0 36 32;
#X connect 3 0 36 31;
#X connect 4 0 36 30;
#X connect 5 0 36 29;
#X connect 6 0 36 28;
#X connect 7 0 36 27;
#X connect 8 0 36 26;
#X connect 9 0 36 25;
#X connect 10 0 36 24;
#X connect 11 0 36 23;
#X connect 12 0 36 22;
#X connect 13 0 36 21;
#X connect 14 0 36 20;
#X connect 15 0 36 19;
#X connect 16 0 36 18;
#X connect 17 0 36 17;
#X connect 18 0 36 16;
#X connect 19 0 36 15;
#X connect 20 0 36 14;
#X connect 21 0 36 13;
#X connect 22 0 36 12;
#X connect 23 0 36 11;
#X connect 24 0 36 10;
#X connect 25 0 36 9;
#X connect 26 0 36 8;
#X connect 27 0 36 7;
#X connect 28 0 36 6;
#X connect 29 0 36 5;
#X connect 30 0 36 4;
#X connect 31 0 36 3;
#X connect 32 0 36 2;
#X connect 33 0 36 1;
#X connect 35 0 40 0;
#X connect 36 0 38 0;
#X connect 37 0 34 0;
#X connect 37 1 34 0;
#X connect 38 0 37 0;
#X connect 40 0 1 0;
#X coords 0 -1 1 1 460 46 2 200 100;
#X restore 121 123 pd x;
#X obj 34 193 osc~ 220;
#X msg 148 264 mode \$1;
#X floatatom 148 241 4 0 3 0 - - - 0;
#X obj 148 218 hradio 15 1 0 4 \$0-dslsjdhfk \$0-dsdsdjfslkjhllsjdhfk empty 0 -8 0 10 #dcdcdc #000000 #000000 0;
#X obj 34 162 nbx 5 14 -1e+37 1e+37 0 0 empty empty empty 0 -8 0 10 #dcdcdc #000000 #000000 0 256;
#X msg 121 184 bits 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0, f 68;
#X obj 308 314 cnv 15 240 85 empty empty empty 20 12 0 14 #f4f4f4 #404040 0;
#X text 317 318 Modes:;
#X text 321 335 0: left as float (don't convert);
#X text 321 348 1: convert left input to integer;
#X text 321 361 2: left as float (don't convert);
#X text 321 374 3: convert left input to integer;
#X text 173 23 Instead of an argument or float input \, you can also specify a bitmask with the "bits" message.;
#X text 240 226 Again \, since there is no audio input in the second inlet \, the modes of conversion don't really make the same sense. The bitmask for comparison is always the same and only the left input is converted to int or not. Thus \, here's how the modes will operate:;
#X text 269 426 The given bitmask as the "bits" message overwrites the given argument \, and a float input in the secondary inlet overwrites the bitmask. If a signal is connected to the second inlet \, it has priority over the given bitmask.;
#X text 173 56 The message "bits" followed by a list of 32 bit values (0 or 1) sets a raw 32 bit data as a bitmask for comparison with the signal input.;
#X obj 34 222 *~ 10000;
#X obj 121 379 /~ 10000;
#X obj 121 339 cyclone/bitsafe~;
#X obj 121 402 clip~ -1 1;
#X obj 121 299 cyclone/bitxor~;
#X obj 139 444 output~;
#X obj 137 519 declare -stdpath ./;
#X obj 140 571 metro 500;
#X obj 121 599 tabwrite~ \$0-array;
#X obj 352 513 cnv 19 198 98 empty empty empty 20 12 0 12 #e0e0e0 #404040 0;
#N canvas 0 50 450 250 (subpatch) 0;
#X array \$0-array 200 float 0;
#X coords 0 -1 199 1 200 100 1;
#X restore 351 512 graph;
#X obj 140 550 loadbang;
#X text 334 505 1;
#X text 334 555 0;
#X text 328 601 -1;
#X connect 0 0 6 0;
#X connect 1 0 17 0;
#X connect 2 0 21 0;
#X connect 3 0 2 0;
#X connect 4 0 3 0;
#X connect 5 0 1 0;
#X connect 6 0 21 0;
#X connect 17 0 21 0;
#X connect 18 0 20 0;
#X connect 19 0 18 0;
#X connect 20 0 22 0;
#X connect 20 0 25 0;
#X connect 21 0 19 0;
#X connect 24 0 25 0;
#X connect 28 0 24 0;
#X restore 459 284 pd raw_bitmask;
#X obj 500 69 cyclone/dsponoff~;
#X obj 2 3 header bitxor~;
#X text 22 63 Signal Bitwise-XOR;
#X floatatom 92 177 13 0 0 0 - - - 0;
#X obj 92 200 sig~;
#X floatatom 179 177 13 0 0 0 - - - 0;
#X obj 179 200 sig~;
#X obj 92 253 cyclone/snapshot~ 1;
#X floatatom 92 278 13 0 0 0 - - - 0;
#X text 90 88 [bitxor~] compares the bits of two values with "Bitwise eXclusive OR" (bits are set to 1 if different \, 0 otherwise). It compares two signals or a signal to a given bitmask. It [bitor~] can produce NaNs and +/-INFs - but denormals are zeroed out and has 4 modes of comparison (see below).;
#X text 24 333 see also;
#X text 39 355 as a vanilla alternative;
#X obj 447 364 open-else;
#X msg 447 337 op~;
#N canvas 294 162 325 299 bitwise-cyclone 0;
#X obj 88 53 cyclone/bitand~;
#X obj 88 82 cyclone/bitnot~;
#X obj 88 111 cyclone/bitor~;
#X obj 88 140 cyclone/bitshift~;
#X obj 88 169 cyclone/bitxor~;
#X obj 91 240 cyclone/bitshift~;
#X text 78 20 All bitwise operators in Cyclone;
#X text 86 211 See also:;
#X restore 82 377 pd bitwise-cyclone;
#X text 49 378 and;
#X obj 85 332 expr~ $v1 ^ $v2;
#X text 217 341 Plugdata users or those with ELSE can also use [else/op~ ^] (both would be the same as" mode 1"), f 33;
#X text 474 336 <- click;
#X connect 10 0 37 0;
#X connect 11 0 10 0;
#X connect 30 0 11 0;
#X connect 37 0 52 0;
#X connect 48 0 49 0;
#X connect 49 0 37 0;
#X connect 50 0 51 0;
#X connect 51 0 37 1;
#X connect 52 0 53 0;
#X connect 58 0 57 0;
